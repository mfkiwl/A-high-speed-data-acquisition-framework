/*****************************************************************************
*	实验流程：
*	1.初始化AXI DMA
*	2.设置Tx和Rx中断
*	3.提交传输
*	4.等待传输完成
*	5.检查传输状态并校验数据
*	6.打印测试结果
******************************************************************************/

#include "COMMON.h"



#define TRANS_LENGTH    512	//发送长度，这里最大值为2^16-1=65535
#define RX_INTR_ID		XPAR_FABRIC_AXI_DMA_0_S2MM_INTROUT_INTR	//RX的中断号
#define UART_DEVICE_ID      XPAR_XUARTPS_0_DEVICE_ID  // the UART device
#define GPIO_DEVICE_ID  	XPAR_XGPIOPS_0_DEVICE_ID  // the gpio device
// #define TX_INTR_ID		XPAR_FABRIC_AXIDMA_0_MM2S_INTROUT_VEC_ID	//TX的中断号
// #define TX_BUFFER_BASE	0x1200000				//TX缓冲区的基地址
#define RX_BUFFER_BASE	0x1400000				//RX缓冲区的基地址

extern XUartPs_Config *Config;
extern XGpioPs Gpio;


int main(void)
{
	int Index;					//计数变量
	// uint16_t Error_Cnt = 0;		//错误计数
	// uint16_t *TxBufferPtr;		//传输数据的指针
	uint16_t *RxBufferPtr;		//接收数据的指针

	//将指针TxBufferPtr指向TX_BUFFER_BASE
	// TxBufferPtr = (uint16_t *)TX_BUFFER_BASE;
	//将指针RxBufferPtr指向RX_BUFFER_BASE
	RxBufferPtr = (uint16_t *)RX_BUFFER_BASE;

	Xil_DCacheDisable(); // 完全禁用数据缓存


	//initialization uart and gpio
	 uart_initial();
	 Gpio_Init();


	//初始化通用中断控制器
	ScuGic_Init();



	//给TxBufferPtr赋值为0~255
	/*for(Index = 0; Index < TRANS_LENGTH; Index ++) {
		TxBufferPtr[Index] = Index;
	}*/


	while(1){
		//初始化AXI DMA
		AXI_DMA_Init(&AxiDma0, XPAR_AXIDMA_0_DEVICE_ID);

		//设置中断服务函数
		// AXI_DMA_TxInt_Init(&AxiDma0, TX_INTR_ID, TxIntrHandler);
		AXI_DMA_RxInt_Init(&AxiDma0, RX_INTR_ID, RxIntrHandler);

		//在开始传输测试之前清除中断状态标志
		TxDone = 0;
		RxDone = 0;
		Error = 0;




		u8 frequency_register;
		u32 buffer_size;
		 // Polling: wait until 1 byte is received
		while (!XUartPs_IsReceiveData(Config->BaseAddress));
		frequency_register = XUartPs_RecvByte(Config->BaseAddress);
		double freq0=(double) frequency_register;
		    // dirve clk1
		clk_wiz_cfg(CLK_WIZ_ID, freq0);



		   u8 lsb, msb;

		             // Wait for and read first byte (LSB)
		             while (!XUartPs_IsReceiveData(Config->BaseAddress)); // Wait for data
		             lsb = XUartPs_RecvByte(Config->BaseAddress);

		             // Wait for and read second byte (MSB)
		             while (!XUartPs_IsReceiveData(Config->BaseAddress)); // Wait for data
		             msb = XUartPs_RecvByte(Config->BaseAddress);

		             buffer_size=(msb << 8) | lsb;

		             //reset the buffer
		             		for(Index = 0; Index < buffer_size/2; Index ++) {
		             					RxBufferPtr[Index] = 0;
		             				}


		             		// enable the input fifo
		             	 XGpioPs_WritePin(&Gpio, EMIO_START_PIN, 1);


	//在DMA传输之前刷新Buffer
	// Xil_DCacheFlushRange((UINTPTR)TxBufferPtr, TRANS_LENGTH*2);


	//开启数据传输
	// XAxiDma_SimpleTransfer(&AxiDma0,(UINTPTR) TxBufferPtr,TRANS_LENGTH*2, XAXIDMA_DMA_TO_DEVICE);

	XAxiDma_SimpleTransfer(&AxiDma0,(UINTPTR) RxBufferPtr,
			buffer_size, XAXIDMA_DEVICE_TO_DMA);

	Xil_DCacheInvalidateRange((UINTPTR)RxBufferPtr, TRANS_LENGTH*2);

	//等待TX完成、或者RX完成、或者传输错误，否则一直等待
	while (!TxDone && !RxDone && !Error) {
		/* 等待 */
	}
   // send the captured data to host


	//send buffer data to host

	//如果发生错误，则打印失败提示
	/*if (Error) {
		printf("DMA Transfer Failed!\n");
	} else {
		//测试完成，检查数据
		for(Index = 0; Index < TRANS_LENGTH; Index++)
		{
			if(RxBufferPtr[Index] != (Index)) {
				Error_Cnt++;
			}
		}
		if(Error_Cnt > 0)
			printf("Test Failed!\n");
		else
			printf("Test Successfully!\n");
	} */


	}

	return 0;
}
